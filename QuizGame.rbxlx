<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Packages</string>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">_Index</string>
        </Properties>
        <Item class="Folder" referent="3">
          <Properties>
            <string name="Name">daulric_exon@0.0.48</string>
          </Properties>
          <Item class="ModuleScript" referent="4">
            <Properties>
              <string name="Name">exon</string>
              <string name="Source">local lockTable = require(script:WaitForChild("lockTable"))

local react = require(script:WaitForChild("react"))

local addons = script:WaitForChild("addons")
local createReactHook = require(addons:WaitForChild("createReactHook"))(react)

local oneframe = require(script:WaitForChild("oneframe"))

local import = require(script:WaitForChild("import"))
local util = require(script:WaitForChild("util"))

local exon = {

    oneframe = oneframe,
    react = react,

    -- Packages
    rednet = require(script:WaitForChild("rednet")),
    db = require(script:WaitForChild("db")),

    -- Utils and Stuff
    controllers = require(script:WaitForChild("controllers")),
    util = util,

    -- Addons,
    addons = {
        createReactHook = createReactHook,
        tidy = require(addons:WaitForChild("tidy")),
        input = require(addons:WaitForChild("input")),
    },

    -- Import Stuff
    import = import,
}

export type exon = typeof(exon)

lockTable(exon, "exon", {
    indexMessage = "(%s) is not a valid member of exon!"
})

return exon</string>
            </Properties>
            <Item class="ModuleScript" referent="5">
              <Properties>
                <string name="Name">import</string>
                <string name="Source">function import(target)
    
    local targetType = typeof(target)
    local newTarget

    if targetType == "table" then
        newTarget = target
    elseif targetType == "Instance" and target:IsA("ModuleScript") then
        newTarget = require(target)
    else
        error(`the target type was {targetType}; the expected target are either a table or a module script; {debug.traceback()}`)
    end

    return function (paths)
        local importedItems = {}

        assert((type(paths) == "table"), `table not recogized; {debug.traceback()}`)

        for i = 1, #paths do

            local path = paths[i]
            local item

            if string.find(path, "/") then
                local nestedPaths = string.split(path, "/")

                for i, v in pairs(nestedPaths) do
                    if i == 1 then
                        item = newTarget[v]
                    else
                        item = item[v]
                    end
                end

            else
                item = newTarget[path]
            end

            if item ~= nil then
                table.insert(importedItems, item)
            end

        end

        return unpack(importedItems)
    end

end

return import</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="6">
              <Properties>
                <string name="Name">lockTable</string>
                <string name="Source">return function (data, id, messages)
    id = id or tostring(data)

    messages.indexMessage = messages.indexMessage or "%q (%s) is not a valid member of %s"

    return setmetatable(data, {
        __tostring = id,

        __index = function(_self, key)
            local message = messages.indexMessage:format(tostring(key), typeof(key), id)

            error(message, 2)
        end,

        __newindex = function(_self, key, _value)
            local message = messages.indexMessage:format(tostring(key), typeof(key), id)

            error(message, 2)
        end,
    })
end</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="7">
              <Properties>
                <string name="Name">addons</string>
              </Properties>
              <Item class="ModuleScript" referent="8">
                <Properties>
                  <string name="Name">createReactHook</string>
                  <string name="Source">local differentDependencies = require(script:WaitForChild("differentDependencies"))
local createUseState = require(script:WaitForChild("createUseState"))
local createUseEffect = require(script:WaitForChild("createUseEffect"))
local createUseBinding = require(script:WaitForChild("createUseBinding"))
local createUseValue = require(script:WaitForChild("createUseValue"))
local createUseMemo = require(script:WaitForChild("createUseMemo"))
local createUseCallback = require(script:WaitForChild("createUseCallback"))
local createUseContext = require(script:WaitForChild("createUseContext"))

function createHooks(react, component)
    local useValue = createUseValue(component)
    local useState = createUseState(component)
    local useEffect = createUseEffect(component)
    local useBinding = createUseBinding(react, useValue)
    local useMemo = createUseMemo(useValue)
    local useCallback = createUseCallback(useMemo)
    local useContext = createUseContext(component, useEffect, useState, useMemo)

    return {
        React = react,
        useBinding = useBinding,
        useCallback = useCallback,
        useContext = useContext,
        useEffect = useEffect,
        useMemo = useMemo,
        useState = useState,
        useValue = useValue,
    }
end

type Hooks = typeof(createHooks())
type Props = {[any]: any}

type render = (Props, Hooks) -> ()

function createReactHook(react)
    return function (render: render, options)

        assert(type(render) == "function", `hooked component have to be a function`)

        if options == nil then
            options = {}
        end

        local componentType = options.componentType
        local name = options.name or debug.info(render, "n")

        local component

        if componentType == nil or componentType == "Component" then
            component = react.Component:extend(name)
        else
            error(
                string.format(
                    "'%s' is not a valid componentType. componentType must either be nil, 'Component'",
					tostring(componentType)
                )
            )
        end

        component.defaultProps = options.defaultProps
        component.validateProps = options.validateProps

        function component:init()
            self.defaultStateValues = {}
            self.effectDependencies = {}
            self.effects = {}
            self.unmountEffects = {}

            self.hooks = createHooks(react, self)
        end

        function component:runEffects()
            for index = 1, self.hookCounter do
				local effectData = self.effects[index]
				if effectData == nil then
					continue
				end

				local effect, dependsOn = unpack(effectData)

				if dependsOn ~= nil then
					local lastDependencies = self.effectDependencies[index]

					if lastDependencies ~= nil and not differentDependencies(dependsOn, lastDependencies) then
						continue
					end

					self.effectDependencies[index] = dependsOn
				end

				local unmountEffect = self.unmountEffects[index]

				if unmountEffect ~= nil then
					unmountEffect()
				end

				self.unmountEffects[index] = effect()
			end
        end

        function component:didMount()
            self:runEffects()
        end

        function component:didUpdate()
            self:runEffects()
        end

        function component:willUnmount()
            for index = 1, self.hookCounter do
				local unmountEffect = self.unmountEffects[index]

				if unmountEffect ~= nil then
					unmountEffect()
				end
			end
        end

        function component:render()
            self.hookCounter = 0
            return render(self.props, self.hooks)
        end

        return component

    end
end

return createReactHook</string>
                </Properties>
                <Item class="ModuleScript" referent="9">
                  <Properties>
                    <string name="Name">createUseBinding</string>
                    <string name="Source">return function (react, useValue)
    return function (defaultVal)
        return unpack(useValue( { react.createBinding(defaultVal) } ).value)
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="10">
                  <Properties>
                    <string name="Name">createUseCallback</string>
                    <string name="Source">return function (useMemo)
    return function (callback, dependencies)
        return useMemo(function()
            return callback
        end, dependencies)
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="11">
                  <Properties>
                    <string name="Name">createUseContext</string>
                    <string name="Source">return function (component, useEffect, useState, useMemo)

    local fakeConsumer = setmetatable({}, {
		__index = component,
	})

	return function(context)
		local defaultValue = useMemo(function()
			local initialValue

			fakeConsumer.props = {
				render = function(value)
					initialValue = value
				end,
			}

			context.Consumer.render(fakeConsumer)
			return initialValue
		end, {})

		context.Consumer.init(fakeConsumer)

		local contextEntry = fakeConsumer.contextEntry

		local value, setValue = useState(
            if contextEntry == nil then
                defaultValue
            else
                contextEntry.value
            )

		useEffect(function()
			if contextEntry == nil then

				if value ~= defaultValue then
					setValue(defaultValue)
				end

				return
			end

			if value ~= contextEntry.value then
				setValue(contextEntry.value)
			end

			return contextEntry.onUpdate:Connect(setValue)
		end, { contextEntry })

		return value
	end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="12">
                  <Properties>
                    <string name="Name">createUseEffect</string>
                    <string name="Source">return function(component)
    return function (callback, dependOn)
        assert(type(callback) == "function", "`useEffect` does not have a function")

        component.hookCounter += 1
        local hookCount = component.hookCounter

        component.effects[hookCount] = {callback, dependOn}
    end
    
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="13">
                  <Properties>
                    <string name="Name">createUseMemo</string>
                    <string name="Source">local differentDependencies = require(script.Parent:WaitForChild("differentDependencies"))

return function(useValue)
    return function (createValue, dependencies)
        local currentVal = useValue(nil)

        local neededRecalulation = dependencies == nil

        if currentVal.value == nil or differentDependencies(dependencies, currentVal.value.dependencies) then
            neededRecalulation = true
        end

        if neededRecalulation then
            currentVal.value = {
				dependencies = dependencies,
				memoizedValue = { createValue() },
			}
        end

        return unpack(currentVal.value.memoizedValue)
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="14">
                  <Properties>
                    <string name="Name">createUseState</string>
                    <string name="Source">local NONE = {}

function extractValue(callbackOrvalue, currentValue)
    if type(callbackOrvalue) == "function" then
        callbackOrvalue(currentValue)
    else
        return callbackOrvalue
    end
end

return function(component)
    local setValues = {}

    return function (defaultValue)
        component.hookCounter += 1

        local hookCount = component.hookCounter
        local value = component.state[hookCount]

        if value == nil then
            local storedValue = component.defaultStateValues[hookCount]
            
            if storedValue == NONE then
                value = nil
            elseif storedValue ~= nil then
                value = storedValue
            elseif type(storedValue) == "function" then
                value = storedValue()

                if value == nil then
                   component.defaultStateValues[hookCount] = NONE
                else
                    component.defaultStateValues[hookCount] = value 
                end
            else
                value = defaultValue
                component.defaultStateValues[hookCount] = value
            end
        elseif value == NONE then
            value = nil
        end

        local setValue = setValues[hookCount]

        if setValue == nil then
            setValue = function(newValue)
                local currentVal = component.state[hookCount]

                if currentVal == nil then
                    currentVal = component.defaultStateValues[hookCount]
                end

                if currentVal == NONE then
                    currentVal = nil
                end

                newValue = extractValue(newValue, currentVal)

                if newValue == nil then
                    newValue = NONE
                end

                component:setState({
                    [hookCount] = newValue
                })

            end

        end

        return value, setValue
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="15">
                  <Properties>
                    <string name="Name">createUseValue</string>
                    <string name="Source">return function (component)
    return function (defaultVal)
        component.hookCounter += 1
        local hookCount = component.hookCounter

        if component.values == nil then
           component.values = {}
        end

        if component.values[hookCount] == nil then
            component.values[hookCount] = {value = defaultVal}
        end

        return component.values[hookCount]
    end
end</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="16">
                  <Properties>
                    <string name="Name">differentDependencies</string>
                    <string name="Source">return function(dependencies, lastDependencies)
	local length = 0

	for index, dependency in pairs(dependencies) do
		length += 1

		if dependency ~= lastDependencies[index] then
			return true
		end
	end

	for _ in pairs(lastDependencies) do
		length -= 1
	end

	if length ~= 0 then
		return true
	end

	return false
end</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="17">
                <Properties>
                  <string name="Name">input</string>
                  <string name="Source">return {
    Keyboard = require(script:WaitForChild("Keyboard")),
    Mouse = require(script:WaitForChild("Mouse")),
}</string>
                </Properties>
                <Item class="ModuleScript" referent="18">
                  <Properties>
                    <string name="Name">Keyboard</string>
                    <string name="Source">local Keyboard = {}
Keyboard.__index = Keyboard

local tidy, rednet = require(script.Parent:WaitForChild("tidy")), require(script.Parent:WaitForChild("rednet"))

local UIS = game:GetService("UserInputService")

function Keyboard.new()
    local keyboard = setmetatable({}, Keyboard)
    keyboard.cleany = tidy.init()
    keyboard.keyup = rednet.createSignal()
    keyboard.keydown = rednet.createSignal()
    keyboard.combination = rednet.createSignal()
    keyboard.keybindings = {}

    keyboard.cleany:addMultiple(keyboard.keyup, keyboard.keydown, keyboard.combination)
    keyboard:setup()
    return keyboard

end

function Keyboard:IsKeyDown(key: Enum.KeyCode): boolean
    return UIS:IsKeyDown(key)
end

function Keyboard:AreKeysDown(key1: Enum.KeyCode, key2: Enum.KeyCode)
    return self:IsKeyDown(key1) and self:IsKeyDown(key2)
end

function Keyboard:IsEitherKeyDown(key1: Enum.KeyCode, key2: Enum.KeyCode)
    return self:IsKeyDown(key1) or self:IsKeyDown(key2)
end

function Keyboard:CreateCombination(name : string, ... : Enum.KeyCode)
    local keys = {...}

    assert(self.keybindings[name] == nil, "name already exsists")

    local connection = UIS.InputBegan:Connect(function(input, proccessed)
        local KeyCode = (input.KeyCode == keys[#keys])

        if proccessed then
            return
        end

        if KeyCode then

            for key, _ in pairs(keys) do
                if not self:IsKeyDown(keys[key]) then
                    return
                end

                self.combination:Fire(name)
            end

        end

    end)
    
    self.keybindings[name] = connection


end

function Keyboard:DismantleCombination(name: string)
    if self.keybindings[name] then
        self.keybindings[name]:Disconnect()
        self.keybindings[name] = nil
    end
end

function Keyboard:setup()
    self.cleany:Connect(UIS.InputBegan, function(input, proccessed)
        if proccessed then
            return
        end

        if input.UserInputType == Enum.UserInputType.Keyboard then
            self.keydown:Fire(input.KeyCode)
        end

    end)

    self.cleany:Connect(UIS.InputEnded, function(input, proccessed)
        if proccessed then
            return
        end

        if input.UserInputType == Enum.UserInputType.Keyboard then
            self.keyup:Fire(input.KeyCode)
        end

    end)

end

function Keyboard:Destroy()
    return self.cleany:Clean()
end

return Keyboard</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="19">
                  <Properties>
                    <string name="Name">Mouse</string>
                    <string name="Source">local Mouse = {}
Mouse.__index = Mouse

local tidy, rednet = require(script.Parent:WaitForChild("tidy")), require(script.Parent:WaitForChild("rednet"))

local UIS = game:GetService("UserInputService")

local default_distance = 1000

function Mouse.new()
    local mouse = setmetatable({}, Mouse)
    mouse._cleany = tidy.init()
    mouse.LeftDown = rednet.createSignal()
    mouse.LeftUp = rednet.createSignal()
    mouse.RightDown = rednet.createSignal()
    mouse.RightUp = rednet.createSignal()
    mouse.Scrolled = rednet.createSignal()

    mouse._cleany:addMultiple(mouse.LeftDown, mouse.LeftUp, mouse.RightDown, mouse.RightUp, mouse.Scrolled)

    mouse:_setup()

    return mouse

end

function Mouse:_setup()
    self._cleany:Connect(UIS.InputBegan, function(input, proccessed)
        if proccessed then
            return
        end

        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.LeftDown:Fire()
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            self.RightDown:Fire()
        end
    end)

    self._cleany:Connect(UIS.InputEnded, function(input, proccessed)
        if proccessed then
            return
        end

        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.LeftUp:Fire()
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            self.RightUp:Fire()
        end

    end)

    self._cleany:Connect(UIS.InputChanged, function(input, processed)
		if processed then
			return
		end

		if input.UserInputType == Enum.UserInputType.MouseWheel then
			self.Scrolled:Fire(input.Position.Z)
		end
	end)

end

function Mouse:IsLeftDown()
    return UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
end

function Mouse:IsRightDown()
    return UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
end

function Mouse:GetDelta()
    return UIS:GetMouseDelta()
end

function Mouse:GetRay(override: Vector2?)
    local mousePos = override or UIS:GetMouseLocation()
	local viewportRay = workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
	return viewportRay
end

function Mouse:Raycast(RaycastParams: RaycastParams, distance: number?, override: Vector2?)

    local viewport = self:GetRay(override)
    local raycast = workspace:Raycast(
        viewport.Origin,
        viewport.Direction * (distance or default_distance),
        RaycastParams
    )

    return raycast
end

function Mouse:Project(distance: number?, override:Vector2?)
    local viewport = self:GetRay(override)
    return viewport.Origin + (viewport.Direction.Unit * (distance or default_distance))
end

function Mouse:Lock()
    UIS.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
end

function Mouse:LockCenter()
    UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
end

function Mouse:Unlock()
    UIS.MouseBehavior = Enum.MouseBehavior.Default
end

function Mouse:Destroy()
    return self._cleany:Clean()
end

return Mouse</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="20">
                  <Properties>
                    <string name="Name">rednet</string>
                    <string name="Source">local RunService = game:GetService("RunService")
local RedNet = {}

local RemoteEvent
local RemoteFunction

if RunService:IsServer() then
    RemoteEvent = Instance.new("RemoteEvent", script)
    RemoteFunction = Instance.new("RemoteFunction", script)
elseif RunService:IsClient() then
    RemoteEvent = script:WaitForChild("RemoteEvent")
    RemoteFunction = script:WaitForChild("RemoteFunction")
end

local Listeners = {}

function ProccessData(id: string, ... : any)

    local tempData = {
        id = id,
        data = {...},
    }

    return tempData
end

function RedNet:FireServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireServer(data)
end

function RedNet:FireClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireClient(player, data)
end

function RedNet:FireAllClients(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireAllClients(data)
end

function RedNet:GetServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeServer(data)
end

function RedNet:GetClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeClient(player, data)
end

function RedNet.listen(id: string, callback : (...any) -> () )

    if Listeners[id] ~= nil then
        warn(`{id} already exsists! \n\n we'll be returning the signal that correspond to that id!`)
        return Listeners[id]
    end

    local listener = {
        _callback = callback,
    }

    function listener:Disconnect()
        Listeners[id] = nil
    end

    Listeners[id] = listener
    return listener
end

function GetListener(temp)

    if temp.id and Listeners[temp.id] then
        return Listeners[temp.id], temp.data
    end

end

function Validate(tempData)
    local success, listener, data = pcall(GetListener, tempData)

    if success and listener ~= nil and data ~= nil then
        return true
    end

end

function NoCallbackMessage(id)
    return `There is no Callback Function; Callback for {id} doesn't exsist!`
end

function ServerListen(player: Player, tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(player, unpack(data))
end

function ClientListen(tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(unpack(data))
end

if RunService:IsServer() then
    RemoteEvent.OnServerEvent:Connect(ServerListen)
    RemoteFunction.OnServerInvoke = ServerListen
elseif RunService:IsClient() then
    RemoteEvent.OnClientEvent:Connect(ClientListen)
    RemoteFunction.OnClientInvoke = ClientListen
end

RedNet.createSignal = require(script:WaitForChild("RemoteSignal"))
RedNet.createBindableSignal = require(script:WaitForChild("BindableSignal"))

return RedNet</string>
                  </Properties>
                  <Item class="ModuleScript" referent="21">
                    <Properties>
                      <string name="Name">BindableSignal</string>
                      <string name="Source">local BSignal = {}

local CLASS_METATABLE = { __index = BSignal}

function BSignal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    return self._bindable:Invoke()
end

function BSignal:Connect(handler)
    self._bindable.OnInvoke = function()
        if self._isConnected == true then
            return handler(table.unpack(self._args, 1, self._argCount))
        end
    end
end

function BSignal:Disconnect()
    self._isConnected = false
end

function BSignal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function createBindableSignal()
    local self = setmetatable({
        _isConnected = true,
        _args = nil,
        _argCount = nil,
        _bindable = Instance.new("BindableFunction"),
    }, CLASS_METATABLE)

    return self
end

return createBindableSignal</string>
                    </Properties>
                  </Item>
                  <Item class="ModuleScript" referent="22">
                    <Properties>
                      <string name="Name">RemoteSignal</string>
                      <string name="Source">local Signal = {}
local CLASS_METATABLE = {__index = Signal}

function Signal:Connect(handler)
    return self._bindable.Event:Connect(function()
        if self._isConnected == true then
            handler(table.unpack(self._args, 1, self._argCount))
        end
    end)
end

function Signal:Once(handler)
    return self._bindable.Event:Once(function()
        handler(table.unpack(self._args, 1, self._argCount))
    end)
end

function Signal:Wait()
    if self._args ~= nil then
        self._bindable.Event:Wait()
        return table.unpack(self._args, 1, self._argCount)
    end
end

function Signal:Disconnect()
    self._isConnected = false
end

function Signal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function Signal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    self._bindable:Fire()
end

function createSignal()

    local self =  setmetatable({
        _bindable = Instance.new("BindableEvent"),
        _isConnected = true,
        _args = nil,
        _argCount = nil,
    }, CLASS_METATABLE)

    return self
end

return createSignal</string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="ModuleScript" referent="23">
                  <Properties>
                    <string name="Name">tidy</string>
                    <string name="Source">local Tidy = {}
Tidy.__index = Tidy

local threadMark = newproxy(true)
local funcMark = newproxy(true)

function getCleaningDetails(obj)

    if typeof(obj) == "RBXScriptConnection" then
        return "Disconnect"
    end

    if typeof(obj) == "Instance" then
        return "Destroy"
    end

    if typeof(obj) == "function" then
        return funcMark
    end

    if typeof(obj) == "thread" then
        return threadMark
    end

    if typeof(obj) == "table" then
        if type(obj.Destroy) == "function" then
            return "Destroy"
        elseif type(obj.destroy) == "function" then
            return "destroy"
        end

        if type(obj.Disconnect) == "function" then
            return "Disconnect"
        elseif type(obj.disconnect) == "function" then
            return "disconnect"
        end
    end

end

function Tidy.init()

    local store = setmetatable({
        isCleaning = false,
        _objects = {}
    }, Tidy)

    return store

end

function Tidy:add(obj)

    assert(self.isCleaning ~= true, `Cleaning in Proccess`)
    local cleanDetail = getCleaningDetails(obj)

    table.insert(self._objects, {
        Type = cleanDetail,
        object = obj
    })

    return obj
end

function Tidy:addMultiple(...)
    local items = {...}
    
    for i, v in pairs(items) do
        self:add(v)
    end

    return items
end

function Tidy:remove(object)
    assert(self._cleaning ~= true, "cleaning in process")

    for i, v in pairs(self._objects) do
        if v.object == object then
           self:__cleanObject(v.object, v.Type)
           table.remove(self._objects, i)
        else
            warn("couldn't find", object, "in the cleanup")
        end
    end
end

function Tidy:Contruct(module)
    if module.new then
        local newMode = module.new()
        return self:add(newMode)
    end
end

function Tidy:Connect(signal, callback)
    local connection = signal:Connect(callback)
    return self:add(connection)
end

function Tidy:__cleanObject(object, method)
    if method == funcMark then
        object()
    elseif method == threadMark then
        coroutine.close(object)
    else
        object[method](object)
    end
end

function Tidy:Clean()
    self.isCleaning = true

    for _, v in pairs(self._objects) do
        self:__cleanObject(v.object, v.Type)
    end

    table.clear(self._objects)
    self.isCleaning = false
end

Tidy.clean = Tidy.Clean
Tidy.destroy = Tidy.Clean
Tidy.contruct = Tidy.Contruct
Tidy.connect = Tidy.Connect

return Tidy</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="24">
                <Properties>
                  <string name="Name">tidy</string>
                  <string name="Source">local Tidy = {}
Tidy.__index = Tidy

local threadMark = newproxy(true)
local funcMark = newproxy(true)

function getCleaningDetails(obj)

    if typeof(obj) == "RBXScriptConnection" then
        return "Disconnect"
    end

    if typeof(obj) == "Instance" then
        return "Destroy"
    end

    if typeof(obj) == "function" then
        return funcMark
    end

    if typeof(obj) == "thread" then
        return threadMark
    end

    if typeof(obj) == "table" then
        if type(obj.Destroy) == "function" then
            return "Destroy"
        elseif type(obj.destroy) == "function" then
            return "destroy"
        end

        if type(obj.Disconnect) == "function" then
            return "Disconnect"
        elseif type(obj.disconnect) == "function" then
            return "disconnect"
        end
    end

end

function Tidy.init()

    local store = setmetatable({
        isCleaning = false,
        _objects = {}
    }, Tidy)

    return store

end

function Tidy:add(obj)

    assert(self.isCleaning ~= true, `Cleaning in Proccess`)
    local cleanDetail = getCleaningDetails(obj)

    table.insert(self._objects, {
        Type = cleanDetail,
        object = obj
    })

    return obj
end

function Tidy:addMultiple(...)
    local items = {...}
    
    for i, v in pairs(items) do
        self:add(v)
    end

    return items
end

function Tidy:remove(object)
    assert(self._cleaning ~= true, "cleaning in process")

    for i, v in pairs(self._objects) do
        if v.object == object then
           self:__cleanObject(v.object, v.Type)
           table.remove(self._objects, i)
        else
            warn("couldn't find", object, "in the cleanup")
        end
    end
end

function Tidy:Contruct(module)
    if module.new then
        local newMode = module.new()
        return self:add(newMode)
    end
end

function Tidy:Connect(signal, callback)
    local connection = signal:Connect(callback)
    return self:add(connection)
end

function Tidy:__cleanObject(object, method)
    if method == funcMark then
        object()
    elseif method == threadMark then
        coroutine.close(object)
    else
        object[method](object)
    end
end

function Tidy:Clean()
    self.isCleaning = true

    for _, v in pairs(self._objects) do
        self:__cleanObject(v.object, v.Type)
    end

    table.clear(self._objects)
    self.isCleaning = false
end

Tidy.clean = Tidy.Clean
Tidy.destroy = Tidy.Clean
Tidy.contruct = Tidy.Contruct
Tidy.connect = Tidy.Connect

return Tidy</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="25">
              <Properties>
                <string name="Name">controllers</string>
                <string name="Source">local Controllers = {}
local symbol = require(script:WaitForChild("symbol"))

local Hub = {}

function Controllers.AddController(instance: Instance)
    local controllers = {}

    for _, module in pairs(instance:GetChildren()) do
        if module:IsA("ModuleScript") then
            local data = require(module)

            if data.symbol then
                table.insert(controllers, data)
            end

        end
    end

    return controllers
end

function Controllers.CreateController(t)
    assert(type(t) == "table", `{t} is not a table; we got a {type(t)}}`)
    assert(type(t.Name) == "string", `There is no name; {t}`)
    assert(Hub[t.Name] == nil, `{t.Name} already exsists`)

    t.symbol = symbol.assign("Controller - "..t.Name)
    Hub[t.Name] = t

    return t
end

function Controllers.GetController(name)
    assert(name ~= nil and type(name) == "string", `There is no name; we got {name}`)
    assert(Hub[name] ~= nil, `There is no {name} controller created!`)

    return Hub[name]
end

return Controllers</string>
              </Properties>
              <Item class="ModuleScript" referent="26">
                <Properties>
                  <string name="Name">symbol</string>
                  <string name="Source">local Symbol = {}

function Symbol.assign(name: string)
    local symbol = newproxy(true)

    getmetatable(symbol).__tostring = function()
        return ("Assign(%s)"):format(name)
    end

    return symbol
end

return Symbol</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="27">
              <Properties>
                <string name="Name">db</string>
                <string name="Source">local DB = {}
DB.__index = DB

-- Getting Services
local DataBaseService = game:GetService("DataStoreService")
local rednet = require(script:WaitForChild("rednet"))
local tidy = require(script:WaitForChild("tidy"))

type ProfileId = string | number
type Database = string | number;
type Table = {[any]: any}

function reconcileTable(template: Table, data: Table)
    for i, v in pairs(template) do
        if data[i] == nil then
            data[i] = v
        elseif type(data[i]) == "table" and type(v) == "table" then
            data[i] = reconcileTable(v, data[i])
        end
    end

    return data
end

function DB.LoadProfile(database: Database, Id: ProfileId, template: Table?)
    local cleanUp = tidy.init()
    template = template or {}

    local profile = {
        _cleanup = cleanUp,
        data = {},
        Settings = {
            EnableAutoSaveEvent = true,
            AutoSaveTime = 10,
        },

        Id = Id,
        template = template,
        Name = database,
        database = DataBaseService:GetDataStore(database),
        isSaving = false,
        isClosing = false,
        isReconciling = false,
        isAutoSavingCancel = false,
        saving = cleanUp:add(rednet.createSignal()),
        reconciled = cleanUp:add(rednet.createSignal()),
    }

    local self = setmetatable(profile, DB)
    self:__get()

    return self
end

function DB:ListenForClosure(callback)
    if type(callback) == "function" then
        self._cleanup:add(callback)
    end
end

function DB:Save(fireSaveEvent: boolean?)

    if fireSaveEvent == nil then
        fireSaveEvent = true
    end

    if self.isSaving == true then
        warn(`[Exon DB]: {self.Id} Profile in {self.Name} Currently Saving Data!`)
        return
    end

    self.isSaving = true

    local function saveData(oldData)
        if oldData == nil then
            oldData = {}
        end

        if self.data ~= nil then
            for i, v in pairs(self.data) do
                oldData[i] = v
            end
        end

        return oldData
    end

    local success, err = pcall(self.database.UpdateAsync, self.database, self.Id, saveData)

    if success then
        if self.saving ~= nil or self.isClosing == true then
            if fireSaveEvent == false then
                return
            end

            self.saving:Fire(self.Id)
        end
    else
        warn(err)
    end

    task.wait()
    self.isSaving = false
end

function DB:AutoSave()
    -- // AutoSaving Data every 30 seconds
    task.spawn(function()
        while task.wait(self.Settings.AutoSaveTime) do
            if self.isAutoSavingCancel == true then
                break
            end

            self:Save(self.Settings.EnableAutoSaveEvent) -- Fire the events in autosaving
            task.wait()
        end
    end)
end

function DB:__get()

    local function getdata(olddata)
        if olddata == nil then
            olddata = {}
        end

        --// Session Locking
        if olddata.sessionId == nil then
            olddata.sessionId = game.JobId
        elseif olddata.sessionId ~= game.JobId then
            warn(`[Exon DB]: {self.Id} profile in {self.Name} is currently opened in another server;`)
            return olddata
        end

        for i, v in pairs(olddata) do
            if i ~= "sessionId" then
                self.data[i] = v
            end
        end

        return olddata
    end

    local success, err = pcall(self.database.UpdateAsync, self.database, self.Id, getdata)

    if not success then
        warn(err)
    end

    -- This returns a cloned frozen version of the data
    return table.freeze(table.clone(self.data))
end

-- // This fills in the missing part of the data from the template
function DB:Reconcile()

    if self.isReconciling == true then
        warn(`[Exon DB]: {self.Id} Profile in {self.Name} is Reconciling Data!`)
        return
    end

    self.isReconciling = true

    -- This compares the template to the actual data and fills in the missing spaces
    reconcileTable(self.template, self.data)
    self.reconciled:Fire(self.Id)
    task.wait()
    self.isReconciling = false
end

-- // This saves and closes the profile!
function DB:Close()

    if self.isClosing == true then
        warn(`[Exon DB]: {self.Id} Profile in {self.Name} Has Closed or Already Closing!`)
        return
    end

    self.isClosing = true

    local success, err = pcall(function()
        self.database:UpdateAsync(self.Id, function(oldData)
            if oldData.sessionId == game.JobId then
                oldData.sessionId = nil
            end

            if self.data ~= nil and type(self.data) == "table" then
                for i, v in pairs(self.data) do
                    oldData[i] = v
                end
            else
                warn("[Exon DB]: The `self.data` either not a table or it doesn't exsist!")
                return
            end

            return oldData
        end)
    end)

    if not success then
        warn(err)
    end

    self.isAutoSavingCancel = true
    self.template = nil
    self.data = nil
    task.wait()
    self._cleanup:Clean()  -- Executes functions and clean objects and events.
    self = {}
end

return DB</string>
              </Properties>
              <Item class="ModuleScript" referent="28">
                <Properties>
                  <string name="Name">rednet</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local RedNet = {}

local RemoteEvent
local RemoteFunction

if RunService:IsServer() then
    RemoteEvent = Instance.new("RemoteEvent", script)
    RemoteFunction = Instance.new("RemoteFunction", script)
elseif RunService:IsClient() then
    RemoteEvent = script:WaitForChild("RemoteEvent")
    RemoteFunction = script:WaitForChild("RemoteFunction")
end

local Listeners = {}

function ProccessData(id: string, ... : any)

    local tempData = {
        id = id,
        data = {...},
    }

    return tempData
end

function RedNet:FireServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireServer(data)
end

function RedNet:FireClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireClient(player, data)
end

function RedNet:FireAllClients(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireAllClients(data)
end

function RedNet:GetServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeServer(data)
end

function RedNet:GetClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeClient(player, data)
end

function RedNet.listen(id: string, callback : (...any) -> () )

    if Listeners[id] ~= nil then
        warn(`{id} already exsists! \n\n we'll be returning the signal that correspond to that id!`)
        return Listeners[id]
    end

    local listener = {
        _callback = callback,
    }

    function listener:Disconnect()
        Listeners[id] = nil
    end

    Listeners[id] = listener
    return listener
end

function GetListener(temp)

    if temp.id and Listeners[temp.id] then
        return Listeners[temp.id], temp.data
    end

end

function Validate(tempData)
    local success, listener, data = pcall(GetListener, tempData)

    if success and listener ~= nil and data ~= nil then
        return true
    end

end

function NoCallbackMessage(id)
    return `There is no Callback Function; Callback for {id} doesn't exsist!`
end

function ServerListen(player: Player, tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(player, unpack(data))
end

function ClientListen(tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(unpack(data))
end

if RunService:IsServer() then
    RemoteEvent.OnServerEvent:Connect(ServerListen)
    RemoteFunction.OnServerInvoke = ServerListen
elseif RunService:IsClient() then
    RemoteEvent.OnClientEvent:Connect(ClientListen)
    RemoteFunction.OnClientInvoke = ClientListen
end

RedNet.createSignal = require(script:WaitForChild("RemoteSignal"))
RedNet.createBindableSignal = require(script:WaitForChild("BindableSignal"))

return RedNet</string>
                </Properties>
                <Item class="ModuleScript" referent="29">
                  <Properties>
                    <string name="Name">BindableSignal</string>
                    <string name="Source">local BSignal = {}

local CLASS_METATABLE = { __index = BSignal}

function BSignal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    return self._bindable:Invoke()
end

function BSignal:Connect(handler)
    self._bindable.OnInvoke = function()
        if self._isConnected == true then
            return handler(table.unpack(self._args, 1, self._argCount))
        end
    end
end

function BSignal:Disconnect()
    self._isConnected = false
end

function BSignal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function createBindableSignal()
    local self = setmetatable({
        _isConnected = true,
        _args = nil,
        _argCount = nil,
        _bindable = Instance.new("BindableFunction"),
    }, CLASS_METATABLE)

    return self
end

return createBindableSignal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="30">
                  <Properties>
                    <string name="Name">RemoteSignal</string>
                    <string name="Source">local Signal = {}
local CLASS_METATABLE = {__index = Signal}

function Signal:Connect(handler)
    return self._bindable.Event:Connect(function()
        if self._isConnected == true then
            handler(table.unpack(self._args, 1, self._argCount))
        end
    end)
end

function Signal:Once(handler)
    return self._bindable.Event:Once(function()
        handler(table.unpack(self._args, 1, self._argCount))
    end)
end

function Signal:Wait()
    if self._args ~= nil then
        self._bindable.Event:Wait()
        return table.unpack(self._args, 1, self._argCount)
    end
end

function Signal:Disconnect()
    self._isConnected = false
end

function Signal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function Signal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    self._bindable:Fire()
end

function createSignal()

    local self =  setmetatable({
        _bindable = Instance.new("BindableEvent"),
        _isConnected = true,
        _args = nil,
        _argCount = nil,
    }, CLASS_METATABLE)

    return self
end

return createSignal</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="31">
                <Properties>
                  <string name="Name">tidy</string>
                  <string name="Source">local Tidy = {}
Tidy.__index = Tidy

local threadMark = newproxy(true)
local funcMark = newproxy(true)

function getCleaningDetails(obj)

    if typeof(obj) == "RBXScriptConnection" then
        return "Disconnect"
    end

    if typeof(obj) == "Instance" then
        return "Destroy"
    end

    if typeof(obj) == "function" then
        return funcMark
    end

    if typeof(obj) == "thread" then
        return threadMark
    end

    if typeof(obj) == "table" then
        if type(obj.Destroy) == "function" then
            return "Destroy"
        elseif type(obj.destroy) == "function" then
            return "destroy"
        end

        if type(obj.Disconnect) == "function" then
            return "Disconnect"
        elseif type(obj.disconnect) == "function" then
            return "disconnect"
        end
    end

end

function Tidy.init()

    local store = setmetatable({
        isCleaning = false,
        _objects = {}
    }, Tidy)

    return store

end

function Tidy:add(obj)

    assert(self.isCleaning ~= true, `Cleaning in Proccess`)
    local cleanDetail = getCleaningDetails(obj)

    table.insert(self._objects, {
        Type = cleanDetail,
        object = obj
    })

    return obj
end

function Tidy:addMultiple(...)
    local items = {...}
    
    for i, v in pairs(items) do
        self:add(v)
    end

    return items
end

function Tidy:remove(object)
    assert(self._cleaning ~= true, "cleaning in process")

    for i, v in pairs(self._objects) do
        if v.object == object then
           self:__cleanObject(v.object, v.Type)
           table.remove(self._objects, i)
        else
            warn("couldn't find", object, "in the cleanup")
        end
    end
end

function Tidy:Contruct(module)
    if module.new then
        local newMode = module.new()
        return self:add(newMode)
    end
end

function Tidy:Connect(signal, callback)
    local connection = signal:Connect(callback)
    return self:add(connection)
end

function Tidy:__cleanObject(object, method)
    if method == funcMark then
        object()
    elseif method == threadMark then
        coroutine.close(object)
    else
        object[method](object)
    end
end

function Tidy:Clean()
    self.isCleaning = true

    for _, v in pairs(self._objects) do
        self:__cleanObject(v.object, v.Type)
    end

    table.clear(self._objects)
    self.isCleaning = false
end

Tidy.clean = Tidy.Clean
Tidy.destroy = Tidy.Clean
Tidy.contruct = Tidy.Contruct
Tidy.connect = Tidy.Connect

return Tidy</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="32">
              <Properties>
                <string name="Name">oneframe</string>
                <string name="Source">local Framework = require(script:WaitForChild("Framework"))
local Component = require(script:WaitForChild("Component"))

local compile = require(script:WaitForChild("freeze"))

local OneFrame = {
    OnStart = Framework,
    Component = Component,
}

compile(OneFrame, "OneFrame")
return OneFrame</string>
              </Properties>
              <Item class="ModuleScript" referent="33">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source">local Component = {}
Component.__index = Component

local tidy = require(script.Parent:WaitForChild("tidy"))

local Marker = require(script.Parent:WaitForChild("Mark"))
local msgTag = "[Exon OneFrame]:"

function Component.create(name)
    local class = setmetatable({
        name = name,
        cleanup = tidy.init(),
        [Marker] = { test = false }
    }, Component)

    setmetatable(class, Component)
    return class
end

function Component:start()
    warn(`{msgTag} Must have a Start Function; {self.name}`)
    return
end

function Component:SetTestMode()
    self[Marker].test = true
end

return Component</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">Framework</string>
                  <string name="Source">local Tools = script.Parent:WaitForChild("Tools")
local Promise = require(Tools:WaitForChild("Promise"))

local Marker = require(script.Parent:WaitForChild("Mark"))

local RunService = game:GetService("RunService")

local msgTag = "[Exon OneFrame]:"

function err(...)
    warn("[Exon OneFrame]:", ...)
end

function Start(scripts, ...)
    xpcall(task.spawn, err, scripts.start, scripts, ... )
end

function preload(scripts, ...)
    if scripts.preload then
        xpcall(task. spawn, err, scripts.preload, scripts, ...)
    end
end

function MsgInfo(ignore, message)
    if not ignore then
        if RunService:IsClient() then
            print("Client:\\\\", message) -- Looks weird cause of roblox string problem
        elseif RunService:IsServer() then
            print("Server:\\\\", message) -- Looks weird cause of roblox string problem
        end
    end
end

function ConnectionTable(scripts, ...)
    task.spawn(function(...)
        preload(scripts, ...)
        task.wait()
        Start(scripts, ...)
    end, ...)

    if scripts.closing and RunService:IsServer() then
        game:BindToClose(function()
            task.spawn(scripts.closing, scripts)
        end)
    end

end

function ConnectionFuncMethod(scripts, ...)
    local items = {...}
    local count = select("#", ...)

    local function onStart(callback)
        return callback(unpack(items, 1, count))
    end

    local function closingmethod(callback)
        if RunService:IsServer() then
            game:BindToClose(function()
                callback()
            end)
        end
    end

    task.spawn(scripts, onStart, closingmethod)
end

function CreateConnection(scripts, Name, ...)
    Name = Name or ""

    local connectType = typeof(scripts)

    assert((connectType ~= "table" or connectType ~= "function"), `{msgTag} There must be a component or a function!`)

    if typeof(scripts) == "table" then
        assert(scripts.name ~= nil, `{msgTag} Must Have a Name!`)
        ConnectionTable(scripts, ...)
    elseif typeof(scripts) == "function" then
        ConnectionFuncMethod(scripts, ...)
    end

    return Name
end

function GetModuleType(module, ignore, ...)
    local success, scripts, Name, Mode = pcall(function()
        local Data = require(module)

        if type(Data) == "table" then
            if Data[Marker] then
                return Data, Data.name, Data[Marker]
            end
        
        elseif typeof(Data) == "function" then
            return Data, module.Name
        end

    end)

    assert(success, `{msgTag} Data could not execute for {Name or module.Name}`)

    if typeof(scripts) == "table" then
        if Mode.test == true and RunService:IsStudio() then
            local message = CreateConnection(scripts, Name, ...)
            MsgInfo(ignore, message)
        else
            local message = CreateConnection(scripts, Name, ...)
            MsgInfo(ignore, message)
        end

    elseif typeof(scripts) == "function" then
        local message = CreateConnection(scripts, Name, ...)
        MsgInfo(ignore, message)
    end

end

function LoopFolder(Folder: Instance, ignore, ...: any)
    for _, instance in pairs(Folder:GetDescendants()) do
        if instance:IsA("ModuleScript") then
            task.spawn(GetModuleType, instance, ignore, ...)
        end
    end
end

function LoopTable(Table, ignore, ...)
    for _, instance in pairs(Table) do
        if typeof(instance) == "Instance"  then
            LoopFolder(instance, ignore, ...)
        elseif typeof(instance) == "table" then
            LoopTable(instance, ignore, ...)
        end
    end
end

function MainFrame(Folder, ...)
    local StartTime = os.time()

    local Items = {...}
    local count = select("#", ...)

    local Success = Promise.new( function(resolve, reject)
        if typeof(Folder) == "Instance" then
            LoopFolder(Folder, nil, unpack(Items, 1, count))
            resolve(Items)
        elseif typeof(Folder) == "table" then
            LoopTable(Folder, nil, unpack(Items, 1, count))
            resolve(Items)
        else
            reject(Items)
        end
    end)

    Success:andThen(function()
        local Finished = os.time() - StartTime
        print(`{Folder.Name} took {Finished} seconds to load!`)
    end)

    return Success
    
end


return MainFrame</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="35">
                <Properties>
                  <string name="Name">Mark</string>
                  <string name="Source">local Symbol = require(script.Parent:WaitForChild("symbol"))

return Symbol.assign("Marker")</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="36">
                <Properties>
                  <string name="Name">Tools</string>
                </Properties>
                <Item class="ModuleScript" referent="37">
                  <Properties>
                    <string name="Name">Promise</string>
                    <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="38">
                <Properties>
                  <string name="Name">freeze</string>
                  <string name="Source">return function(data: {[any]: any}, name)

	name = name or tostring(data)

    local success, completed = pcall(function()
		local Name = tostring(data)

		return setmetatable(data, {
			__index = function(_self, key)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), Name)

				error(message, 2)
			end,

			__newindex = function(_self, key, _value)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), Name)

				error(message, 2)
			end,

			__tostring = function()
				return name
			end
		})
	end)

    if success then
        return completed
    end

end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="39">
                <Properties>
                  <string name="Name">symbol</string>
                  <string name="Source">local Symbol = {}

function Symbol.assign(name: string)
    local symbol = newproxy(true)

    getmetatable(symbol).__tostring = function()
        return ("Assign(%s)"):format(name)
    end

    return symbol
end

return Symbol</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="40">
                <Properties>
                  <string name="Name">tidy</string>
                  <string name="Source">local Tidy = {}
Tidy.__index = Tidy

local threadMark = newproxy(true)
local funcMark = newproxy(true)

function getCleaningDetails(obj)

    if typeof(obj) == "RBXScriptConnection" then
        return "Disconnect"
    end

    if typeof(obj) == "Instance" then
        return "Destroy"
    end

    if typeof(obj) == "function" then
        return funcMark
    end

    if typeof(obj) == "thread" then
        return threadMark
    end

    if typeof(obj) == "table" then
        if type(obj.Destroy) == "function" then
            return "Destroy"
        elseif type(obj.destroy) == "function" then
            return "destroy"
        end

        if type(obj.Disconnect) == "function" then
            return "Disconnect"
        elseif type(obj.disconnect) == "function" then
            return "disconnect"
        end
    end

end

function Tidy.init()

    local store = setmetatable({
        isCleaning = false,
        _objects = {}
    }, Tidy)

    return store

end

function Tidy:add(obj)

    assert(self.isCleaning ~= true, `Cleaning in Proccess`)
    local cleanDetail = getCleaningDetails(obj)

    table.insert(self._objects, {
        Type = cleanDetail,
        object = obj
    })

    return obj
end

function Tidy:addMultiple(...)
    local items = {...}
    
    for i, v in pairs(items) do
        self:add(v)
    end

    return items
end

function Tidy:remove(object)
    assert(self._cleaning ~= true, "cleaning in process")

    for i, v in pairs(self._objects) do
        if v.object == object then
           self:__cleanObject(v.object, v.Type)
           table.remove(self._objects, i)
        else
            warn("couldn't find", object, "in the cleanup")
        end
    end
end

function Tidy:Contruct(module)
    if module.new then
        local newMode = module.new()
        return self:add(newMode)
    end
end

function Tidy:Connect(signal, callback)
    local connection = signal:Connect(callback)
    return self:add(connection)
end

function Tidy:__cleanObject(object, method)
    if method == funcMark then
        object()
    elseif method == threadMark then
        coroutine.close(object)
    else
        object[method](object)
    end
end

function Tidy:Clean()
    self.isCleaning = true

    for _, v in pairs(self._objects) do
        self:__cleanObject(v.object, v.Type)
    end

    table.clear(self._objects)
    self.isCleaning = false
end

Tidy.clean = Tidy.Clean
Tidy.destroy = Tidy.Clean
Tidy.contruct = Tidy.Contruct
Tidy.connect = Tidy.Connect

return Tidy</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="41">
              <Properties>
                <string name="Name">react</string>
                <string name="Source">-- \\ Utils // --
local nodes = script:WaitForChild("nodes")
local markers = script:WaitForChild("markers")

local data = require(markers:WaitForChild("data"))

local createElement = require(nodes:WaitForChild("createElement"))
local createFragment = require(nodes:WaitForChild("createFragment"))
local createContext = require(nodes:WaitForChild("createContext"))
local ComponentAspect = require(script:WaitForChild("Component"))
local createRef = require(nodes:WaitForChild("createRef"))
local forwardRef = require(nodes:WaitForChild("forwardRef"))

local Binding = require(script:WaitForChild("Binding"))

-- Reconciler v2
local renderer = require(script:WaitForChild("Renderer"))
local Reconciler = require(script:WaitForChild("Reconciler"))(renderer)

-- \\ compile // --
local freeze = require(script:WaitForChild("freeze"))

local react = {
    mount = Reconciler.mountVirtualTree,
    unmount = Reconciler.unmountVirtualTree,
    update = Reconciler.updateVirtualTree,

    createElement = createElement,
    createFragment = createFragment,
    createContext = createContext,
    createRef = createRef,
    createBinding = Binding.create,
    forwardRef = forwardRef,

    --// Event, Property, and Attribute Signals
    Bind = Binding.bind_key,
    Change = data.Change,
    Event = data.Event,
    AttributeChange = data.AttributeChange,

    --// Attributes and Children
    Attribute = data.Attribute,
    Children = require(markers.Children),
    Gateway = require(markers.Gateway),
    Ref = require(markers.Ref),

    Component = ComponentAspect,
}

freeze(react, "react")
return react</string>
              </Properties>
              <Item class="ModuleScript" referent="42">
                <Properties>
                  <string name="Name">Binding</string>
                  <string name="Source">local rednet = require(script.Parent:WaitForChild("rednet"))
local Symbol = require(script.Parent:WaitForChild("symbol"))
local ElementType = require(script.Parent.markers.ElementType)

local BindingImpl = Symbol.assign("BindingImpl")

local BindingInternalApi = {}
BindingInternalApi.bind_key = BindingImpl

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("ReactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = rednet.createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:Connect(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:Fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		Type = ElementType.Types.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(_newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		Type = ElementType.Types.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, connection in pairs(disconnects) do
				connection:Disconnect()
			end

			disconnects = nil :: any
		end
	end

	function impl.update(_newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		Type = ElementType.Types.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="43">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source">local markers = script.Parent:WaitForChild("markers")
local ComponentLifecyclePhase = require(markers:WaitForChild("Lifecycle"))
local Symbol = require(script.Parent:WaitForChild("symbol"))
local ElementType = require(markers:WaitForChild("ElementType"))
local assign = require(script.Parent:WaitForChild("assign"))

local None = Symbol.assign("None")

local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.assign("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a React component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component.Type = ElementType.Types.StatefulComponent
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of React to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)

	local class = {}

	for key, value in pairs(self) do
		if key ~= "extend" then
			class[key] = value
		end
	end

	class.Type = ElementType.Types.StatefulComponent
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	if
		lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate
		or lifecyclePhase == ComponentLifecyclePhase.WillUpdate
		or lifecyclePhase == ComponentLifecyclePhase.Render
	then
		local messageTemplate = "error when calling state in %s"

		local message = messageTemplate:format(tostring(internalData.componentClass))
		error(message, 2)
	elseif lifecyclePhase == ComponentLifecyclePhase.WillUnmount then
		return
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)
	elseif
		lifecyclePhase == ComponentLifecyclePhase.DidMount
		or lifecyclePhase == ComponentLifecyclePhase.DidUpdate
		or lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)
	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		self:__update(nil, newState)
	else
		local messageTemplate = "Error : %s"

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(tostring(internalData.componentClass))

	error(message, 0)
end

function Component:__getContext(key)

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

function Component:__addContext(key, value)

	local virtualNode = self[InternalData].virtualNode

	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

function Component:__validateProps(props)

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(
			("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
				typeof(validator),
				self.__componentName
			)
		)
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "&lt;Validator function did not supply a message>"
		error(
			("Property validation failed in %s: %s\n\n%s"):format(
				self.__componentName,
				tostring(failureReason),
				self:getElementTraceback() or "&lt;enable element tracebacks>"
			),
			0
		)
	end
end

function Component:__mount(reconciler, virtualNode)

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
		pendingState = nil,
	}

	local instance = {
		Type = ElementType.Types.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateChildren(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountNode(childNode)
	end
end

function Component:__update(updatedElement, updatedState)

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

function Component:__resolveUpdate(incomingProps, incomingState)

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateChildren(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="44">
                <Properties>
                  <string name="Name">Reconciler</string>
                  <string name="Source">local markers = script.Parent:WaitForChild("markers")
local ElementType = require(markers:WaitForChild("ElementType"))
local Symbol = require(script.Parent:WaitForChild("symbol"))
local Children = require(markers:WaitForChild("Children"))

local InternalData = Symbol.assign("Internal Data")

function createReconciler(renderer)
    local reconciler

    local mountNode
    local unmountNode
    local updateNode

    local function replaceVirtualNode(virtualNode: VirtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local parent = virtualNode.parent
        local depth = virtualNode.depth

		if not virtualNode.wasUnmounted then
			unmountNode(virtualNode)
		end

		local newNode = mountNode(newElement, hostParent)

		if newNode ~= nil then
			newNode.depth = depth
			newNode.parent = parent
		end

		return newNode
	end

    local function updateChildren(virtualNode: VirtualNode, hostParent, newChildElements)
        virtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1

		local currentUpdateChildrenCount = virtualNode.updateChildrenCount

		local removeKeys = {}

		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementType.getElementByID(newChildElements, childKey)

			local newNode = updateNode(childNode, newElement)

			if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
				if newNode and newNode ~= virtualNode.children[childKey] then
					unmountNode(newNode)
				end

				return
			end

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		for childKey, newElement in ElementType.iterateElements(newChildElements) do

			if virtualNode.children[childKey] == nil then
				local childNode = mountNode(
					newElement,
					hostParent,
                    virtualNode.context,
                    virtualNode.legacyContext
				)

				if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
					if childNode then
						unmountNode(childNode)
					end

					return
				end

				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					childNode.parent = virtualNode
					virtualNode.children[childKey] = childNode
				end

			end
		end
    end

    local function createVirtualNode(element, hostParent, context, legacyContext)
        return {
            currentElement = element,
            Type = ElementType.Types.Element,
            hostParent = hostParent,
            depth = 0,
            wasUnmounted = false,
            parent = nil,
            object = nil,
            updateChildrenCount = 0,
            children = {},
            context = context or {},
            legacyContext = legacyContext,
            parentLegacyContext = legacyContext,
            originalContext = nil
        }
    end

    type VirtualNode = typeof(createVirtualNode())

    local function mountFunctionalNode(virtualNode: VirtualNode)
        local currentElement = virtualNode.currentElement
        local stuff = currentElement.class(currentElement.props)
        updateChildren(virtualNode, virtualNode.hostParent, stuff)
    end

    local function mountFragmentNode(virtualNode: VirtualNode)
        local currentElement = virtualNode.currentElement
        local children = currentElement.elements

        updateChildren(virtualNode, virtualNode.hostParent, children)
    end

    local function mountGatewayNode(virtualNode: VirtualNode)
        local currentElement = virtualNode.currentElement
        local path = currentElement.props.path
        local children = currentElement.props[Children]

        assert(renderer.isHostObject(path), `{path} is not a valid object`)

        updateChildren(virtualNode, path, children)
    end

    function mountNode(element, hostParent, context, legacyContext)
        local virtualNode = createVirtualNode(element, hostParent, context, legacyContext)
        local currentElement = virtualNode.currentElement

        local Type = ElementType.of(element)

        if Type == ElementType.Types.Host then
            renderer.mountHostNode(virtualNode, reconciler)
        elseif Type == ElementType.Types.Functional then
            mountFunctionalNode(virtualNode)
        elseif Type == ElementType.Types.Fragment then
            mountFragmentNode(virtualNode)
        elseif Type == ElementType.Types.Gateway then
            mountGatewayNode(virtualNode)
        elseif Type == ElementType.Types.StatefulComponent then
            currentElement.class:__mount(reconciler, virtualNode)
        end

        return virtualNode
    end

    local function unmoutVirtualNodeChildren(virtualNode: VirtualNode)
        for i, v in pairs(virtualNode.children) do
            unmountNode(v)
        end
    end

    function unmountNode(virtualNode: VirtualNode)
        local element = virtualNode.currentElement
        local Type = ElementType.of(element)

        if Type == ElementType.Types.Host then
            renderer.unmountHostNode(virtualNode, reconciler)
        elseif Type == ElementType.Types.Functional then
            unmoutVirtualNodeChildren(virtualNode)
        elseif Type == ElementType.Types.Fragment then
            unmoutVirtualNodeChildren(virtualNode)
        elseif Type == ElementType.Types.Gateway then
            unmoutVirtualNodeChildren(virtualNode)
        elseif Type == ElementType.Types.StatefulComponent then
            virtualNode.instance:__unmount()
        else
            error(`Unknown Element Virtual Tree ID: {element}`)
        end

    end

    local function updateFunctionalNode(virtualNode: VirtualNode, newElement)
        local children = newElement.class(newElement.props)
        updateChildren(virtualNode, virtualNode.hostParent, children)
        return virtualNode
    end

    local function updateGatewayNode(virtualNode: VirtualNode, newElement)
        local oldElement = virtualNode.currentElement
        local oldPath = oldElement.props.path

        local hostPath = newElement.props.path

        if oldPath ~= hostPath then
            return replaceVirtualNode(virtualNode, newElement)
        end

        local children = newElement.props[Children]

        updateChildren(virtualNode, hostPath, children)

        return virtualNode
    end

    local function updateFragmentNode(virtualNode: VirtualNode, newElement)
        updateChildren(virtualNode, virtualNode.hostParent, newElement.elements)
        return virtualNode
    end

    function updateNode(virtualNode: VirtualNode, newElement, newState)
        if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

        local Type = ElementType.of(newElement)
        local shouldContinueUpdate = true

        if Type == ElementType.Types.Host then
            virtualNode = renderer.updateHostNode(virtualNode, reconciler, newElement)
        elseif Type == ElementType.Types.Functional then
            virtualNode = updateFunctionalNode(virtualNode, newElement)
        elseif Type == ElementType.Types.Fragment then
            virtualNode = updateFragmentNode(virtualNode, newElement)
        elseif Type == ElementType.Types.Gateway then
            virtualNode = updateGatewayNode(virtualNode, newElement)
        elseif Type == ElementType.Types.StatefulComponent then
            shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
        else
            error("Unknown Element Type!")
        end

        if not shouldContinueUpdate then
			return virtualNode
		end

        virtualNode.currentElement = newElement
        return virtualNode
    end

    local function mountVirtualTree(element, hostParent)
        local tree = {
            Type = ElementType.Types.VirtualTree,
            [InternalData] = {
                rootNode = nil,
                mounted = true,
            }
        }

        tree[InternalData].rootNode = mountNode(element, hostParent)
        return tree
    end

    local function updateVirtualTree(tree, newElement)
        local InternalData = tree[InternalData]
        InternalData.rootNode = updateNode(InternalData.rootNode, newElement)
        return tree
    end

    local function unmountVirtualTree(virtualTree)
        if virtualTree[InternalData].rootNode then
            local rootNode = virtualTree[InternalData].rootNode
            unmountNode(rootNode)
        end
    end

    reconciler = {
        updateChildren = updateChildren,
        replaceVirtualNode = replaceVirtualNode,
        mountNode = mountNode,
        unmountNode = unmountNode,
        updateNode = updateNode,
        mountVirtualTree = mountVirtualTree,
        updateVirtualTree = updateVirtualTree,
        unmountVirtualTree = unmountVirtualTree,
    }

    return reconciler

end

return createReconciler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="45">
                <Properties>
                  <string name="Name">Renderer</string>
                  <string name="Source">local renderer = {}
local markers = script.Parent:WaitForChild("markers")
local Type = require(markers:WaitForChild("Type"))
local ElementType = require(markers:WaitForChild("ElementType"))

local Binding = require(script.Parent:WaitForChild("Binding"))

local Children = require(markers.Children)
local Ref = require(markers.Ref)

local SingleEventManager = require(script.Parent:WaitForChild("SingleEventManager"))

local getDefaultInstanceProperty = require(script.Parent:WaitForChild("getDefaultProperty"))

local function identity(...)
    return ...
end

local function applyRef(ref, newObject)
    if ref == nil then
        return
    end

    if typeof(ref) == "function" then
		ref(newObject)
	elseif ElementType.of(ref) == ElementType.Types.Binding then
		Binding.update(ref, newObject)
	else
		error(("Invalid ref: Expected type Binding but got %s"):format(typeof(ref)))
	end

end

local function removeBinding(virtualNode, key)
    local disconnect = virtualNode.bindings[key]
    disconnect()
    virtualNode.bindings[key] = nil
end

local function setDefaultProperty(object, key, newValue)
    if newValue == nil then
		local hostClass = object.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	object[key] = newValue

	return
end

local function attachBinding(virtualNode, key, newBinding)
    local function updateBoundProperty(newValue)

		local success, errorMessage = xpcall(function()
			setDefaultProperty(virtualNode.object, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "&lt;enable element tracebacks>"
			end

			local fullMessage = ("Apply Props Error (%s) (%s)"):format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)
	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
    if virtualNode.bindings ~= nil then
		for _, connection in pairs(virtualNode.bindings) do
           if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
           end
		end

		virtualNode.bindings = nil
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
    if newValue == oldValue then
        return
    end

    if key == Children or key == Ref then
        return
    end

    local KeyType = ElementType.of(key)

    if KeyType == Type.Event or KeyType == Type.Change or KeyType == Type.AttributeChange then
        if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.object)
		end

		local eventName = key.name

		if KeyType == Type.Change then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
        elseif KeyType == Type.AttributeChange then
            virtualNode.eventManager:connectAttributeChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

        return
    end

    local newIsBinding = (ElementType.of(newValue) == ElementType.Types.Binding)
    local oldIsBinding = (ElementType.of(oldValue) == ElementType.Types.Binding)

    if oldIsBinding then
        removeBinding(virtualNode, key)
    end

    if newIsBinding then
        attachBinding(virtualNode, key, newValue)
    else
        setDefaultProperty(virtualNode.object, key, newValue)
    end

end

local function applyProps(virtualNode, props)
    for key, value in pairs(props) do
        applyProp(virtualNode, key, value, nil)
    end
end

function updateProps(virtualNode, oldProps, newProps)

    -- Updating Props
    for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]
		applyProp(virtualNode, propKey, newValue, oldValue)
	end

    -- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end

end

function renderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function renderer.mountHostNode(virtualNode, reconciler)
    local element = virtualNode.currentElement
    local hostParent = virtualNode.hostParent

    local instance = Instance.new(element.class)
    virtualNode.object = instance
    instance.Name = tostring(virtualNode.hostKey)

    local success, errorMessage = xpcall(function()
        applyProps(virtualNode, element.props)
    end, identity)

    if not success then

        local source = element.source

		if source == nil then
			source = "&lt;enable element tracebacks>"
		end

        error(source.." : "..errorMessage)

    end

    local children = element.props[Children]

    if children ~= nil then
        reconciler.updateChildren(virtualNode, virtualNode.object, children)
    end

    instance.Parent = hostParent
    virtualNode.object = instance

    applyRef(element.props[Ref], instance)

    if virtualNode.eventManager ~= nil then
        virtualNode.eventManager:resume()
    end

end

function renderer.unmountHostNode(virtualNode, reconciler)
    local element = virtualNode.currentElement

    applyRef(element.props[Ref], nil)

    for i, node in pairs(virtualNode.children) do
        reconciler.unmountNode(node)
    end

    detachAllBindings(virtualNode)
    virtualNode.object:Destroy()
end

function renderer.updateHostNode(virtualNode, reconciler, newElement)
    local oldProps = virtualNode.currentElement.props
    local newProps = newElement.props

    if virtualNode.eventManager then
        virtualNode.eventManager:suspend()
    end

    if oldProps[Ref] ~= newProps[Ref] then
        applyRef(oldProps[Ref], nil)
        applyRef(newProps[Ref], virtualNode.object)
    end

    local success, err = xpcall(function()
        updateProps(virtualNode, oldProps, newProps)
    end, identity)

    if not success then
        local source = newElement.source

        if source == nil then
            source = "&lt;element tracebacks>"
        end

        error(`{source}:{err}`)
    end

    local children = newElement.props[Children]

    if children ~= nil or oldProps[Children] ~= nil then
        reconciler.updateChildren(virtualNode, virtualNode.hostParent, children)
    end

    if virtualNode.eventManager then
        virtualNode.eventManager:resume()
    end

    return virtualNode
end

return renderer</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="46">
                <Properties>
                  <string name="Name">SingleEventManager</string>
                  <string name="Source">local CHANGE_PREFIX = "Change."
local ATTRIBTE_PREFIX = "AttributeChange."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(tostring(key), event), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:connectAttributeChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetAttributeChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(tostring(key), event), 0)
	end

	self:_connect(ATTRIBTE_PREFIX..key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		
		if self._connections[eventKey] == nil then

			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)

			self._listeners[eventKey] = listener
		end
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()

	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	while index &lt;= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		if listener ~= nil then

			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount)
			)

			if not success then
				warn("There was an error!", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="47">
                <Properties>
                  <string name="Name">assign</string>
                  <string name="Source">local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				target[key] = value
			end
		end

	end

	return target
end

return assign</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="48">
                <Properties>
                  <string name="Name">getDefaultProperty</string>
                  <string name="Source">local Symbol = require(script.Parent:WaitForChild("symbol"))

local Nil = Symbol.assign("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="49">
                <Properties>
                  <string name="Name">markers</string>
                </Properties>
                <Item class="ModuleScript" referent="50">
                  <Properties>
                    <string name="Name">Children</string>
                    <string name="Source">local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

local Children = Symbol.assign("Children")

return Children</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="51">
                  <Properties>
                    <string name="Name">ElementType</string>
                    <string name="Source">local ElementTypeInternal = {}

type ElementKindType = typeof(ElementTypeInternal)

local ElementType: ElementKindType = newproxy(true)

local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

local Gateway = require(script.Parent:WaitForChild("Gateway"))

local ElementKindType = {
    Host = Symbol.assign("react.Element.Host"),
    Functional = Symbol.assign("react.Element.Function"),
    StatefulComponent = Symbol.assign("react.Element.StatefulComponent"),
    StatefulComponentInstance = Symbol.assign("react.Component.Instance"),

    --// Other Stuff
    Fragment = Symbol.assign("react.Fragment"),
    Gateway = Symbol.assign("react.Gateway"),
    Element = Symbol.assign("react.Element"),
    VirtualTree = Symbol.assign("react.VirtualTree"),
    Binding = Symbol.assign("Binding")
}

ElementTypeInternal.Types = ElementKindType
ElementTypeInternal.Key = Symbol.assign("Private Key")

local Types = {
    ["string"] = ElementKindType.Host,
    ["function"] = ElementKindType.Functional,
    [Gateway] = ElementKindType.Gateway
}

function noop()
    return nil
end

function ElementTypeInternal.typeof(element)

    if Types[typeof(element)] then
        return Types[typeof(element)]
    end

    if element == Gateway then
        return Types[Gateway]
    end

    if typeof(element) == "table" then
        if element.Type == ElementKindType.StatefulComponent then
            return ElementKindType.StatefulComponent
        end

        if element.Type == ElementKindType.Fragment then
            return ElementKindType.Fragment
        end
    end

end

function ElementTypeInternal.of(element)

    if type(element) ~= "table" then
        return nil
    end

    return element.Type
end

function ElementTypeInternal.iterateElements(index)

    local regType = typeof(index)
    local richType = ElementTypeInternal.of(index)

    if index.Type then

        local called = false

        return function (_, _)
            if called then
                return nil 
            else
                called = true
                return ElementTypeInternal.Key, index
            end
        end

    end

    if index == nil or regType == "boolean" then
        return (noop :: any)
    end

    if regType == "table" then
        return pairs(index)
    end

    error("This is not a valid elements! "..tostring(index))
end

function ElementTypeInternal.getElementByID(elements, key)

    if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if elements.Type == ElementTypeInternal.Types.Element then
		if key == ElementTypeInternal.Key then
            print("Got a Table using Private Key!")
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[key]
	end

	error("Invalid elements")

end

getmetatable(ElementType).__index = ElementTypeInternal

return ElementType</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="52">
                  <Properties>
                    <string name="Name">Gateway</string>
                    <string name="Source">local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

local Gateway = Symbol.assign("Gateway")

return Gateway</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="53">
                  <Properties>
                    <string name="Name">Lifecycle</string>
                    <string name="Source">local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

return {
    DidMount = Symbol.assign("DidMount"),
    WillUpdate = Symbol.assign("willUpdate"),
    DidUpdate = Symbol.assign("didUpdate"),
    WillUnmount = Symbol.assign("willUnmount"),
    ReconcileChildren = Symbol.assign("ReconcileChildren"),
    Render = Symbol.assign("Render"),
    Init = Symbol.assign("Init"),
    Idle = Symbol.assign("Idle"),
    ShouldUpdate = Symbol.assign("Should Update"),

    Updating = Symbol.assign("Updating"),
    Mounting = Symbol.assign("Mounting"),
    Unmounting = Symbol.assign("Unmounting"),
    Pending = Symbol.assign("Pending"),
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="54">
                  <Properties>
                    <string name="Name">Ref</string>
                    <string name="Source">local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

local ref = Symbol.assign("Ref")

return ref</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="55">
                  <Properties>
                    <string name="Name">Type</string>
                    <string name="Source">local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

return {
    -- // Event, Property, and Attribute Signals for Events
    Event = Symbol.assign("react.Event"),
    Change = Symbol.assign("react.Change"),
    Attribute = Symbol.assign("react.Attribute"),
    AttributeChange = Symbol.assign("react.Attribute.Change"),
}</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="56">
                  <Properties>
                    <string name="Name">data</string>
                    <string name="Source">local data = {}
local markers = script.Parent
local Type = require(markers.Type)
local setTable = require(script.setTable)

data.Change = {}
data.Event = {}
data.Attribute = {}
data.AttributeChange = {}

-- this is for property and attribute change signals

setTable(data.Change, "react.Change", Type.Change, true)
setTable(data.Event, "react.Event", Type.Event, true)
setTable(data.Attribute, "react.Attribute", Type.Attribute)
setTable(data.AttributeChange, "react.Attribute.Change", Type.AttributeChange, true)

return data</string>
                  </Properties>
                  <Item class="ModuleScript" referent="57">
                    <Properties>
                      <string name="Name">setTable</string>
                      <string name="Source">return function (Table, message, PropertyType, isEvent)
    setmetatable(Table, {
        __index = function(_self, index)
            local listener = {
                name = index,
                Type = PropertyType,
                Event = isEvent
            }
    
            setmetatable(listener, {
                __tostring = function(self)
                    return (`{message}(%s)`):format(self.name)
                end
            })
            return listener
        end
    })
end</string>
                    </Properties>
                  </Item>
                </Item>
              </Item>
              <Item class="Folder" referent="58">
                <Properties>
                  <string name="Name">nodes</string>
                </Properties>
                <Item class="ModuleScript" referent="59">
                  <Properties>
                    <string name="Name">createContext</string>
                    <string name="Source">local Component = require(script.Parent.Parent:WaitForChild("Component"))
local createFragment = require(script.Parent:WaitForChild("createFragment"))
local rednet = require(script.Parent.Parent:WaitForChild("rednet"))
local Children = require(script.Parent.Parent:WaitForChild("markers"):WaitForChild("Children"))
local Symbol = require(script.Parent.Parent:WaitForChild("symbol"))

function createIndex(value)
    return {
        value = value,
        onUpdate = rednet.createSignal()
    }
end

function createProducer(context)
    local Producer = Component:extend("Producer Component")

    function Producer:init(props)
        self.contextEntry = createIndex(props.value)
        self:__addContext(context.key, self.contextEntry)
    end

    function Producer:willUpdate(nextProps)
        if nextProps.value ~= self.props.value then
            self.contextEntry.value = nextProps.value
        end
    end

    function Producer:didUpdate(prevProps)
        if prevProps.value ~= self.props.value then
            self.contextEntry.onUpdate:Fire(self.props.value)
        end
    end

    function Producer:render()
        return createFragment(self.props[Children])
    end

   return Producer
end

function createConsumer(context)
    local Consumer = Component:extend("Consumer")

    function Consumer.validateProps(props)
        if type(props.render) ~= "function" then
            return false, "The Consumer Expects a Function"
        else
            return true
        end
    end

    function Consumer:init()
        self.contextEntry = self:__getContext(context.key)
    end

    function Consumer:didUpdate()
        if self.contextEntry ~= nil then
            self.lastValue = self.contextEntry.value
        end
    end

    function Consumer:didMount()
        if self.contextEntry ~= nil then
            self.connection = self.contextEntry.onUpdate:Connect(function(newValue)
                if newValue ~= self.lastValue then
                    self:setState({})
                end
            end)
        end
    end

    function Consumer:willUnmount()
        if self.connection then
            self.connection:Disconnect()
            self.connection = nil
        end
    end

    function Consumer:render()
        local value

        if self.contextEntry ~= nil then
            value = self.contextEntry.value
        else
            value = context.defaultEntry
        end

        return self.props.render(value)
    end

    return Consumer
end

local Context = {}
Context._index = Context

function Context.new(defaultEntry)
    return setmetatable({
        defaultEntry = defaultEntry,
        key = Symbol.assign("Context Key")
    }, Context)
end

function Context.__tostring()
    return "Context Provider"
end

function createContext(entry)
    local context = Context.new(entry)

    return {
        Producer = createProducer(context),
        Consumer = createConsumer(context)
    }
end

return createContext</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="60">
                  <Properties>
                    <string name="Name">createElement</string>
                    <string name="Source">local markers = script.Parent.Parent:WaitForChild("markers")

local ElementType = require(markers.ElementType)
local Children = require(markers.Children)

function extractData(ProccessChildren, children)


    if type(ProccessChildren) ~= "table" then return end

    for i, child in pairs(ProccessChildren) do
        if type(child) == "table" then
            if child.Type ~= nil then
                children[i] = child
            else
                extractData(child, children)
            end
        end
    end

end

function createElement(class, props, ...: any)

    local processChildren = {...}
    local children = {}

    props = props or {}

    if processChildren ~= nil then

        extractData(processChildren, children)

        if props[Children] ~= nil then
            warn("there is already children in the props")
            return
        end

        props[Children] = children
    end

    local index = {
        Type = ElementType.typeof(class),
        class = class,
        props = props,
        children = children
    }

    return index
end

return createElement</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="61">
                  <Properties>
                    <string name="Name">createFragment</string>
                    <string name="Source">local markers = script.Parent.Parent:WaitForChild("markers")
local ElementType = require(markers.ElementType)

function createFragment(elements)
    return {
        Type = ElementType.Types.Fragment,
        elements = elements,
    }
end

return createFragment</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="62">
                  <Properties>
                    <string name="Name">createRef</string>
                    <string name="Source">local Binding = require(script.Parent.Parent:WaitForChild("Binding"))

function createRef()
    local bind, _ = Binding.create(nil)

    local ref = {}

    setmetatable(ref, {
        __index = function(_self, key)
			if key == "value" then
				return bind:getValue()
			else
				return bind[key]
			end
		end,
		__newindex = function(_self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			bind[key] = value
		end,
		__tostring = function(_self)
			return ("react.Ref(%s)"):format(tostring(bind:getValue()))
		end,
    })

    return ref

end

return createRef</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="63">
                  <Properties>
                    <string name="Name">forwardRef</string>
                    <string name="Source">local Ref = require(script.Parent.Parent:WaitForChild("markers").Ref)
local assign = require(script.Parent.Parent:WaitForChild("assign"))

function forwardRef(render)
    return function (props)
        local ref = props[Ref]
        local PropsWithNoRef = assign({}, props)

        return render(PropsWithNoRef, ref)
    end
end

return forwardRef</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">freeze</string>
                  <string name="Source">return function(data: {[any]: any}, name)

	name = name or tostring(data)

    local success, completed = pcall(function()
		local Name = tostring(data)

		return setmetatable(data, {
			__index = function(_self, key)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), Name)

				error(message, 2)
			end,

			__newindex = function(_self, key, _value)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), Name)

				error(message, 2)
			end,

			__tostring = function()
				return name
			end
		})
	end)

    if success then
        return completed
    end

end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">rednet</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local RedNet = {}

local RemoteEvent
local RemoteFunction

if RunService:IsServer() then
    RemoteEvent = Instance.new("RemoteEvent", script)
    RemoteFunction = Instance.new("RemoteFunction", script)
elseif RunService:IsClient() then
    RemoteEvent = script:WaitForChild("RemoteEvent")
    RemoteFunction = script:WaitForChild("RemoteFunction")
end

local Listeners = {}

function ProccessData(id: string, ... : any)

    local tempData = {
        id = id,
        data = {...},
    }

    return tempData
end

function RedNet:FireServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireServer(data)
end

function RedNet:FireClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireClient(player, data)
end

function RedNet:FireAllClients(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireAllClients(data)
end

function RedNet:GetServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeServer(data)
end

function RedNet:GetClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeClient(player, data)
end

function RedNet.listen(id: string, callback : (...any) -> () )

    if Listeners[id] ~= nil then
        warn(`{id} already exsists! \n\n we'll be returning the signal that correspond to that id!`)
        return Listeners[id]
    end

    local listener = {
        _callback = callback,
    }

    function listener:Disconnect()
        Listeners[id] = nil
    end

    Listeners[id] = listener
    return listener
end

function GetListener(temp)

    if temp.id and Listeners[temp.id] then
        return Listeners[temp.id], temp.data
    end

end

function Validate(tempData)
    local success, listener, data = pcall(GetListener, tempData)

    if success and listener ~= nil and data ~= nil then
        return true
    end

end

function NoCallbackMessage(id)
    return `There is no Callback Function; Callback for {id} doesn't exsist!`
end

function ServerListen(player: Player, tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(player, unpack(data))
end

function ClientListen(tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(unpack(data))
end

if RunService:IsServer() then
    RemoteEvent.OnServerEvent:Connect(ServerListen)
    RemoteFunction.OnServerInvoke = ServerListen
elseif RunService:IsClient() then
    RemoteEvent.OnClientEvent:Connect(ClientListen)
    RemoteFunction.OnClientInvoke = ClientListen
end

RedNet.createSignal = require(script:WaitForChild("RemoteSignal"))
RedNet.createBindableSignal = require(script:WaitForChild("BindableSignal"))

return RedNet</string>
                </Properties>
                <Item class="ModuleScript" referent="66">
                  <Properties>
                    <string name="Name">BindableSignal</string>
                    <string name="Source">local BSignal = {}

local CLASS_METATABLE = { __index = BSignal}

function BSignal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    return self._bindable:Invoke()
end

function BSignal:Connect(handler)
    self._bindable.OnInvoke = function()
        if self._isConnected == true then
            return handler(table.unpack(self._args, 1, self._argCount))
        end
    end
end

function BSignal:Disconnect()
    self._isConnected = false
end

function BSignal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function createBindableSignal()
    local self = setmetatable({
        _isConnected = true,
        _args = nil,
        _argCount = nil,
        _bindable = Instance.new("BindableFunction"),
    }, CLASS_METATABLE)

    return self
end

return createBindableSignal</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="67">
                  <Properties>
                    <string name="Name">RemoteSignal</string>
                    <string name="Source">local Signal = {}
local CLASS_METATABLE = {__index = Signal}

function Signal:Connect(handler)
    return self._bindable.Event:Connect(function()
        if self._isConnected == true then
            handler(table.unpack(self._args, 1, self._argCount))
        end
    end)
end

function Signal:Once(handler)
    return self._bindable.Event:Once(function()
        handler(table.unpack(self._args, 1, self._argCount))
    end)
end

function Signal:Wait()
    if self._args ~= nil then
        self._bindable.Event:Wait()
        return table.unpack(self._args, 1, self._argCount)
    end
end

function Signal:Disconnect()
    self._isConnected = false
end

function Signal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function Signal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    self._bindable:Fire()
end

function createSignal()

    local self =  setmetatable({
        _bindable = Instance.new("BindableEvent"),
        _isConnected = true,
        _args = nil,
        _argCount = nil,
    }, CLASS_METATABLE)

    return self
end

return createSignal</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="68">
                <Properties>
                  <string name="Name">symbol</string>
                  <string name="Source">local Symbol = {}

function Symbol.assign(name: string)
    local symbol = newproxy(true)

    getmetatable(symbol).__tostring = function()
        return ("Assign(%s)"):format(name)
    end

    return symbol
end

return Symbol</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="69">
              <Properties>
                <string name="Name">rednet</string>
                <string name="Source">local RunService = game:GetService("RunService")
local RedNet = {}

local RemoteEvent
local RemoteFunction

if RunService:IsServer() then
    RemoteEvent = Instance.new("RemoteEvent", script)
    RemoteFunction = Instance.new("RemoteFunction", script)
elseif RunService:IsClient() then
    RemoteEvent = script:WaitForChild("RemoteEvent")
    RemoteFunction = script:WaitForChild("RemoteFunction")
end

local Listeners = {}

function ProccessData(id: string, ... : any)

    local tempData = {
        id = id,
        data = {...},
    }

    return tempData
end

function RedNet:FireServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireServer(data)
end

function RedNet:FireClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireClient(player, data)
end

function RedNet:FireAllClients(id: string, ... : any)
    local data = ProccessData(id, ...)
    RemoteEvent:FireAllClients(data)
end

function RedNet:GetServer(id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeServer(data)
end

function RedNet:GetClient(player: Player, id: string, ... : any)
    local data = ProccessData(id, ...)
    return RemoteFunction:InvokeClient(player, data)
end

function RedNet.listen(id: string, callback : (...any) -> () )

    if Listeners[id] ~= nil then
        warn(`{id} already exsists! \n\n we'll be returning the signal that correspond to that id!`)
        return Listeners[id]
    end

    local listener = {
        _callback = callback,
    }

    function listener:Disconnect()
        Listeners[id] = nil
    end

    Listeners[id] = listener
    return listener
end

function GetListener(temp)

    if temp.id and Listeners[temp.id] then
        return Listeners[temp.id], temp.data
    end

end

function Validate(tempData)
    local success, listener, data = pcall(GetListener, tempData)

    if success and listener ~= nil and data ~= nil then
        return true
    end

end

function NoCallbackMessage(id)
    return `There is no Callback Function; Callback for {id} doesn't exsist!`
end

function ServerListen(player: Player, tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(player, unpack(data))
end

function ClientListen(tempData)
    local listener, data = GetListener(tempData)
    assert(Validate(tempData) == true, NoCallbackMessage(tempData.id))
    return listener._callback(unpack(data))
end

if RunService:IsServer() then
    RemoteEvent.OnServerEvent:Connect(ServerListen)
    RemoteFunction.OnServerInvoke = ServerListen
elseif RunService:IsClient() then
    RemoteEvent.OnClientEvent:Connect(ClientListen)
    RemoteFunction.OnClientInvoke = ClientListen
end

RedNet.createSignal = require(script:WaitForChild("RemoteSignal"))
RedNet.createBindableSignal = require(script:WaitForChild("BindableSignal"))

return RedNet</string>
              </Properties>
              <Item class="ModuleScript" referent="70">
                <Properties>
                  <string name="Name">BindableSignal</string>
                  <string name="Source">local BSignal = {}

local CLASS_METATABLE = { __index = BSignal}

function BSignal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    return self._bindable:Invoke()
end

function BSignal:Connect(handler)
    self._bindable.OnInvoke = function()
        if self._isConnected == true then
            return handler(table.unpack(self._args, 1, self._argCount))
        end
    end
end

function BSignal:Disconnect()
    self._isConnected = false
end

function BSignal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function createBindableSignal()
    local self = setmetatable({
        _isConnected = true,
        _args = nil,
        _argCount = nil,
        _bindable = Instance.new("BindableFunction"),
    }, CLASS_METATABLE)

    return self
end

return createBindableSignal</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="71">
                <Properties>
                  <string name="Name">RemoteSignal</string>
                  <string name="Source">local Signal = {}
local CLASS_METATABLE = {__index = Signal}

function Signal:Connect(handler)
    return self._bindable.Event:Connect(function()
        if self._isConnected == true then
            handler(table.unpack(self._args, 1, self._argCount))
        end
    end)
end

function Signal:Once(handler)
    return self._bindable.Event:Once(function()
        handler(table.unpack(self._args, 1, self._argCount))
    end)
end

function Signal:Wait()
    if self._args ~= nil then
        self._bindable.Event:Wait()
        return table.unpack(self._args, 1, self._argCount)
    end
end

function Signal:Disconnect()
    self._isConnected = false
end

function Signal:Destroy()
    if self._bindable then
        self._bindable:Destroy()
        self._bindable = nil
    end

    self._argCount = nil
    self._args = nil
    self._isConnected = false
end

function Signal:Fire(...)
    self._args = {...}
    self._argCount = select("#", ...)
    self._bindable:Fire()
end

function createSignal()

    local self =  setmetatable({
        _bindable = Instance.new("BindableEvent"),
        _isConnected = true,
        _args = nil,
        _argCount = nil,
    }, CLASS_METATABLE)

    return self
end

return createSignal</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="72">
              <Properties>
                <string name="Name">util</string>
                <string name="Source">return {
    iterate = require(script:WaitForChild("iterate")),
    createCounter = require(script:WaitForChild("createCounter")),
    createLoop = require(script:WaitForChild("createLoop")),
}</string>
              </Properties>
              <Item class="ModuleScript" referent="73">
                <Properties>
                  <string name="Name">createCounter</string>
                  <string name="Source">return function (t1:number, t2: number, increment: number, func)
    local breakValue

    for index = t1, t2, increment do
        breakValue = func(index, func)

        if breakValue == false then
            return
        end

    end

    return breakValue
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="74">
                <Properties>
                  <string name="Name">createLoop</string>
                  <string name="Source">return function (item, func)
    local breakValue

    while item do
        breakValue = func(item, func)

        if breakValue == false then
            break
        end

    end

    return breakValue
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="75">
                <Properties>
                  <string name="Name">iterate</string>
                  <string name="Source">return function (t, func)
    local breakValue

    for index, value in pairs(t) do
        breakValue = func(index, value, func)

        if breakValue == false then
            break
        end

    end

    return breakValue
end</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="76">
        <Properties>
          <string name="Name">exon</string>
          <string name="Source"><![CDATA[return require(script.Parent._Index["daulric_exon@0.0.48"]["exon"])
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="77">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="Folder" referent="78">
        <Properties>
          <string name="Name">Components</string>
        </Properties>
        <Item class="ModuleScript" referent="79">
          <Properties>
            <string name="Name">CompileQuizUI</string>
            <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Exon = require(ReplicatedStorage:WaitForChild("Packages").exon)

local OneFrame = Exon.oneframe
local React = Exon.react

local QuizUIFolder = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("QuizUI")

local Component = require(QuizUIFolder.Quiz)

local CompileQuiz = OneFrame.Component.create("Compile Quiz UI")


function CompileQuiz:start()

    local Element = React.createElement(Component)

    local player = Players.LocalPlayer or Players.PlayerAdded:Wait()

    player.CharacterAdded:Connect(function()
        React.mount(Element, player.PlayerGui)
    end)
end

return CompileQuiz</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="80">
        <Properties>
          <string name="Name">Others</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="81">
        <Properties>
          <string name="Name">QuizUI</string>
        </Properties>
        <Item class="Folder" referent="82">
          <Properties>
            <string name="Name">Buttons</string>
          </Properties>
          <Item class="ModuleScript" referent="83">
            <Properties>
              <string name="Name">OptionButton</string>
              <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local OptionButtonComponent = react.Component:extend("Option Button")

function OptionButtonComponent:init()
    self.clickSound = react.createRef()
end

function OptionButtonComponent:didMount()
    self.sound = self.clickSound:getValue()
end

function OptionButtonComponent:render()

    return react.createElement("TextButton", {
        Name = "Option Button",
        Text = self.props.Text,
        RichText = true,
        TextScaled = true,
        BackgroundColor3 = Color3.fromRGB(46, 46, 46),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Size = UDim2.new(0.5, 0, 0.5, 0),
        Font = Enum.Font.Cartoon,
        [react.Event.MouseButton1Click] = function(element)
            self.sound:Play()
            self.props.mouseClicked(element)
        end,
    }, {

        Children = react.createFragment(self.props[react.Children]),

        UICorner = react.createElement("UICorner", {
            CornerRadius = UDim.new(0, 5),
        }),

        Sound = react.createElement("Sound", {
            SoundId = "rbxassetid://5393362166",
            [react.Ref] = self.clickSound,
        }),

        UIRatio = react.createElement("UIAspectRatioConstraint", {
            AspectRatio = 5,
            AspectType = Enum.AspectType.ScaleWithParentSize,
        })
    })
end

return OptionButtonComponent</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="84">
          <Properties>
            <string name="Name">Items</string>
          </Properties>
          <Item class="ModuleScript" referent="85">
            <Properties>
              <string name="Name">QuestionLabel</string>
              <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local QuizQuestionComponent = react.Component:extend("QuizQuestionLabel")

function QuizQuestionComponent:init()
    self.text, self.updateText = react.createBinding("Question Area")
end

function QuizQuestionComponent:render()
    return react.createElement("TextLabel", {
        Name = "Question Label",
        Position = UDim2.fromScale(0.364, 0.15),
        Size = UDim2.fromScale(0.316,0.143),
        Text = self.props.Question,
        RichText = true,
        BackgroundTransparency = 1,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        TextScaled = true,
    }, {
        UIScaled = react.createElement("UIAspectRatioConstraint", {
            AspectRatio = 5,
        }),
    })
end


return QuizQuestionComponent</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="86">
            <Properties>
              <string name="Name">ScoreLabel</string>
              <string name="Source">local Players = game:GetService("Players")
local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local ScoreLabelComponent = react.Component:extend("Score Label")

function ScoreLabelComponent:init()
    self.Score, self.updateScore = react.createBinding(0)
end

function ScoreLabelComponent:didMount()
    local player = Players.LocalPlayer

    player:GetAttributeChangedSignal("Score"):Connect(function()
        self.updateScore(player:GetAttribute("Score"))
    end)

end

function ScoreLabelComponent:render()
    return react.createElement("TextLabel", {
        Name = "Score Label",
        Text = self.Score:map(function(value)
            return "Score: "..value
        end),

        Size = UDim2.fromScale(0.2, 0.065),
        Position = UDim2.fromScale(0.748, 0),
        Font = Enum.Font.Cartoon,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 1,
        TextScaled = true,

    }, {
        UIRatio = react.createElement("UIAspectRatioConstraint", {
            AspectRatio = 5,
        })
    })
end

return ScoreLabelComponent</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="87">
          <Properties>
            <string name="Name">QAHandler</string>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local exon = require(ReplicatedStorage.Packages.exon)

local react = exon.react
local rednet = exon.rednet

local ScreenFolder = script.Parent:WaitForChild("Screen")
local ItemsFolder = script.Parent:WaitForChild("Items")

local QuestionLabel = require(ItemsFolder.QuestionLabel)
local ButtonArea = require(ScreenFolder.ButtonArea)

local QAHandler = react.Component:extend("QA Handler")

local OptionButton = require(script.Parent:WaitForChild("Buttons").OptionButton)

function QAHandler:init()
    self.question, self.updateQuestion = react.createBinding("")
    self.questionData, self.updateQuestionData = react.createBinding({})
    self:setState({
        Buttons = {},
    })

end

function QAHandler:didMount()
    print("QA handler Did Mount")

    rednet.listen("QuizGetNow", function(data)
        self.updateQuestionData(data)
    end)

    self.questionData[react.Bind].subscribe(function(data)
        local results = data.results
        local tempStore = {}
        local buttons = {}
        local Answered = false

        for i = 1, #results do
            local Question_Queue = results[i]

            self.updateQuestion(Question_Queue.question)
            table.insert(tempStore, Question_Queue.correct_answer)

            for i, v in pairs(Question_Queue.incorrect_answers) do
                table.insert(tempStore, v)
            end

            for i = 1, #tempStore do
                local chosenNum = math.random(1, #tempStore)
                local soundRef = react.createRef()
                local element = react.createElement(OptionButton, {
                    Text = tempStore[chosenNum],
                    mouseClicked = function(element)
                        local soundPlayer = soundRef:getValue()

                        if Answered == true then
                            return
                        end

                        if element.Text == Question_Queue.correct_answer then
                            element.BackgroundColor3 = Color3.fromRGB(30, 70, 9)
                            rednet:FireServer("score_update", true)
                            soundPlayer.SoundId = "rbxassetid://9060788686"
                            soundPlayer:Play()
                        else
                            element.BackgroundColor3 = Color3.fromRGB(84, 11, 11)
                            rednet:FireServer("score_update", false)
                            soundPlayer.SoundId = "rbxassetid://1637297605"
                            soundPlayer:Play()
                        end

                        Answered = true
                    end
                }, {
                    Sound = react.createElement("Sound", {
                        Name = "Success/Failure",
                        SoundId = "",
                        [react.Ref] = soundRef,
                    })
                })

                table.insert(buttons, element)
                table.remove(tempStore, chosenNum)
            end

            self:setState({
                Buttons = buttons
            })

            repeat
                task.wait(1)
            until (Answered == true)

            task.wait(2)
            Answered = false
            table.clear(tempStore)
            table.clear(buttons)

            if i == #results then
                rednet:FireServer("resend_quiz")
            end

        end
    end)

end

function QAHandler:render()
    return react.createFragment({
        QuestionLabel = react.createElement(QuestionLabel, {
            Question = self.question:map(function(value) return value end),
        }),
        ButtonArea = react.createElement(ButtonArea, {}, {
            Buttons = react.createFragment(self.state.Buttons),
        }),
    })
end


return QAHandler</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="88">
          <Properties>
            <string name="Name">Quiz</string>
            <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local QuizComponent = react.Component:extend("QuizUI")

-- Components
local ScreenFolder = script.Parent:WaitForChild("Screen")
local ItemsFolder = script.Parent:WaitForChild("Items")

local QuizScreen = require(ScreenFolder.Screen)
local Label = require(ScreenFolder.Label)
local ScoreLabel = require(ItemsFolder.ScoreLabel)

local QAHandler = require(script.Parent:WaitForChild("QAHandler"))

function QuizComponent:init()
    self:setState({
        Buttons = {}, -- Can Hold Up to 4 Buttons!
    })
end

function QuizComponent:render()
    return react.createElement("ScreenGui", {
        Name = "Quiz Panel",
        IgnoreGuiInset = true,
    }, self.props[react.Children], {
        ScreenElement = react.createElement(QuizScreen, {}, {
            Label = react.createElement(Label),
            QA = react.createElement(QAHandler),
            ScoreLabel = react.createElement(ScoreLabel),
        })
    })
end

return QuizComponent</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="89">
          <Properties>
            <string name="Name">Screen</string>
          </Properties>
          <Item class="ModuleScript" referent="90">
            <Properties>
              <string name="Name">ButtonArea</string>
              <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local ButtonArea = react.Component:extend("Button Area")

function ButtonArea:render()
    return react.createElement("Frame", {
        Name = "Button Area",
        Size = UDim2.fromScale(0.5, 0.4),
        Position = UDim2.fromScale(0.3, 0.4),
        BackgroundColor3 = Color3.fromRGB(61, 61, 61)
    }, self.props[react.Children],  {

        UICorner = react.createElement("UICorner", {
            CornerRadius = UDim.new(0, 4),
        }),

        UIAspect = react.createElement("UIAspectRatioConstraint", {
            AspectRatio = 3
        }),

        UIGridLayout = react.createElement("UIGridLayout", {
            HorizontalAlignment = Enum.HorizontalAlignment.Center,
            VerticalAlignment = Enum.VerticalAlignment.Center,
            CellPadding = UDim2.fromOffset(5, 5),
            CellSize = UDim2.fromOffset(200, 50),
        })
    })
end

return ButtonArea</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="91">
            <Properties>
              <string name="Name">Label</string>
              <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react


local ScreenComponent = react.Component:extend("Quiz Screen Component")

function ScreenComponent:render()
    return react.createElement("TextLabel", {
        Name = "Quiz Name",
        Text = "Quiz",
        Size = UDim2.new(0.1, 0, 0.1, 0),
        Position = UDim2.fromScale(0.5, 0),
        BackgroundTransparency = 1,
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Font = Enum.Font.Cartoon,
        TextScaled = true,
    }, {
        UIScaled = react.createElement("UIAspectRatioConstraint", {}),
    })
end


return ScreenComponent</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="92">
            <Properties>
              <string name="Name">Screen</string>
              <string name="Source">local exon = require(game.ReplicatedStorage.Packages.exon)

local react = exon.react

local ScreenComponent = react.Component:extend("Quiz Screen Component")

function ScreenComponent:render()
    return react.createElement("Frame", {
        Name = "Quiz Frame",
        Size = UDim2.new(1, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(36, 36, 36),
    }, self.props[react.Children])
end


return ScreenComponent</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="93">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="94">
      <Properties>
        <string name="Name">Server</string>
      </Properties>
      <Item class="Script" referent="95">
        <Properties>
          <string name="Name">Execute</string>
          <token name="RunContext">0</token>
          <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Exon = require(ReplicatedStorage:WaitForChild("Packages").exon)

local OneFrame = Exon.oneframe
local Components = ServerStorage:WaitForChild("Shared").Components

print("Waiting For Client To Load!")
OneFrame.OnStart(Components):andThen(function()
    print("Server Components Loaded Successfully!")
end)</string>
        </Properties>
      </Item>
      <Item class="Script" referent="96">
        <Properties>
          <string name="Name">FreezePlayer</string>
          <token name="RunContext">0</token>
          <string name="Source">local Players = game:GetService("Players")

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        char.HumanoidRootPart.Anchored = true
    end)
end)</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="97">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Folder" referent="98">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="Folder" referent="99">
        <Properties>
          <string name="Name">Components</string>
        </Properties>
        <Item class="ModuleScript" referent="100">
          <Properties>
            <string name="Name">ControllersExecute</string>
            <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RS = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local exon = require(RS.Packages.exon)


local oneframe = exon.oneframe
local Controllers = exon.controllers
local ControllersFolder = ServerStorage:WaitForChild("Shared").Controllers

return function(start)
    start(function()
        Controllers.AddController(ControllersFolder)
    end)
end 
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="101">
          <Properties>
            <string name="Name">Database</string>
            <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local exon = require(ReplicatedStorage.Packages.exon)

local OneFrame = exon.oneframe
local db = exon.db
local rednet = exon.rednet
local util = exon.util

local DatabaseComponent = OneFrame.Component.create("Database Manager")

function DatabaseComponent:preload()
    self.profiles = {}
end

function DatabaseComponent:playerAdded(player: Player)
    local profile = db.LoadProfile("Player Databbase", player.UserId, {
        Score = 0,
    })

    profile:Reconcile()

    profile.saving:Connect(function()
        print("Saving Data")
    end)

    self.profiles[player.UserId] = profile

    for i, v in pairs(profile.data) do
        player:SetAttribute(i, v)
    end

    profile:AutoSave()
end

function DatabaseComponent:playerRemoved(player: Player)
    local profile = self.profiles[player.UserId]
    profile:Save()
    profile:Close()
end

function DatabaseComponent:start()

    for i, v in pairs(Players:GetPlayers()) do
        self:playerAdded(v)
    end

    Players.PlayerAdded:Connect(function(player)
        self:playerAdded(player)
    end)

    rednet.listen("score_update", function(player, increment)
        local profile = self.profiles[player.UserId]

        if increment == true then
            profile.data.Score += 10
        else
            if profile.data.Score > 0 then
                profile.data.Score -= 10
            end
        end

        player:SetAttribute("Score", profile.data.Score)
    end)

end

function DatabaseComponent:closing()
    util.iterate(Players:GetPlayers(), function(_, player: Player)
        self:playerRemoved(player)
    end)
end

return DatabaseComponent</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="102">
          <Properties>
            <string name="Name">QuizDataManager</string>
            <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Exon = require(ReplicatedStorage.Packages.exon)

local OneFrame = Exon.oneframe
local Controllers = Exon.controllers
local RedNet = Exon.rednet

local QuizApi = Controllers.GetController("Quiz Api")

local QuizManager = OneFrame.Component.create("Quiz Manager")

function QuizManager:preload()
    self.isAdded = {}

    self.mode = {
        [1] = "easy",
        [2] = "medium",
        [3] = "hard",
    }

    self.count = 0
end

function QuizManager:GetQuiz(player: Player)

    self.count += 1

    if self.count > #self.mode then
        self.count = 1
    end

    QuizApi:Get(20, self.mode[self.count], "multiple")
    task.wait()
    RedNet:FireClient(player, "QuizGetNow", QuizApi.Info.QuizInfo)
end

function QuizManager:playerAdded(player)
    print("player added")
    if self.isAdded[player.UserId] == nil then
        self.isAdded[player.UserId] = true
        task.wait(2)
        self:GetQuiz(player)
        print("sent the data")
    end
end

function QuizManager:playerRemoved(player)
    self.isAdded[player.UserId] = nil
end

function QuizManager:start()

    for i, v in pairs(Players:GetPlayers()) do
        self:playerAdded(v)
    end

    RedNet.listen("resend_quiz", function(player)
        self:GetQuiz(player)
    end)

    Players.PlayerAdded:Connect(function(player)
        self:playerAdded(player)
    end)

    Players.PlayerRemoving:Connect(function(player)
        self:playerRemoved(player)
    end)

end


return QuizManager</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="103">
        <Properties>
          <string name="Name">Controllers</string>
        </Properties>
        <Item class="ModuleScript" referent="104">
          <Properties>
            <string name="Name">QuizApi</string>
            <string name="Source">local HttpService = game:GetService("HttpService")
local exon = require(game.ReplicatedStorage.Packages.exon)

local HttpService = game:GetService("HttpService")

local Controllers = exon.controllers
local rednet = exon.rednet

local QuizApi = Controllers.CreateController {
    Name = "Quiz Api",
    Info = {
        QuizInfo = {}
    },

    Signal = rednet.createSignal(),
}

type GameType = "multiple" | "boolean";
type difficulty = "easy" | "hard" | "medium";

function QuizApi:Fire(data)
    self.Signal:Fire(data)
end

-- Getting Info using the API
function QuizApi:Get(amount: number, difficulty: difficulty, type: GameType)
    local url = `https://opentdb.com/api.php?amount={amount}&amp;category=18&amp;difficulty={difficulty}&amp;type={type}`
    local urlData = HttpService:GetAsync(url, true)
    local info = HttpService:JSONDecode(urlData)

    table.clear(self.Info.QuizInfo)

    for i, v in pairs(info) do
        self.Info.QuizInfo[i] = v
    end
end



return QuizApi</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="105">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="106">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="107">
        <Properties>
          <string name="Name">Client</string>
        </Properties>
        <Item class="LocalScript" referent="108">
          <Properties>
            <string name="Name">Execute</string>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)

local Exon = require(ReplicatedStorage.Packages.exon)
local OneFrame = Exon.oneframe

local ClientFolder = ReplicatedStorage.Shared.Components
OneFrame.OnStart(ClientFolder):andThen(function()
    print("Client Loaded!")
end)</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>